/**
 * osgGIS - GIS Library for OpenSceneGraph
 * Copyright 2007 Glenn Waldron and Pelican Ventures, Inc.
 * http://osggis.org
 *
 * osgGIS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef _OSGGIS_SCRIPT_H_
#define _OSGGIS_SCRIPT_H_ 1

#include <osgGIS/Common>
#include <osgGIS/ScriptContext>
#include <osgGIS/FeatureFilter>
#include <osgGIS/NodeFilter>
#include <osgGIS/FilterEnv>
#include <list>

namespace osgGIS
{
    /**
     * A chain of data-processing filters.
     *
     * A Script is a sequence of discrete data-processing units called Filters.
     * The compiler will run a script using a set of input features (typically
     * from a FeatureStore/Featurelayer) and a filter environment (FilterEnv)
     * that communicates the current spatial context. The compiler passes data
     * from filter to filter until it reaches the end of the chain. It then
     * invokes getOutput() and returns the resulting scene graph to the caller.
     *
     * Although some basic type validation occurs, the responsibility lies with
     * the caller to build a working script that passes compatible data down the
     * chain.
     */
    class OSGGIS_EXPORT Script : public osg::Referenced
    {
    public:
        /**
         * Construct a new, empty script.
         */
        Script();

        /**
         * Gets the name of this script.
         */
        const std::string& getName() const;

        /**
         * Sets the name of this script.
         */
        void setName( const std::string& name );

        /**
         * Appends a filter to the end of the script's filter chain.
         *
         * @param filter
         *      Filter to attach to the end of the chain. The filter's input
         *      requirements much be commpatible with the preceding filter's
         *      output specification.
         *
         * @return
         *      True if the filter appended succesfully.
         */
        bool appendFilter( Filter* filter );

        /**
         * Resets each filter in the chain to its initial state.
         *
         * @param context
         *      Script-level context data
         */
        void resetFilters( ScriptContext* context );
        
        /**
         * Executes the script by passing features to the first filter in the
         * chain. That filter will process the data, pass the results along to
         * the next filter, and so on until completion.
         *
         * @param cursor
         *      Source cursor for features to process
         * @param env
         *      Contextual compilation environment
         * @return
         *      True if the filter chain completed without error; false otherwise.
         */
        bool run( FeatureCursor* cursor, FilterEnv* env );
        
        /**
         * After a call to run(), calling this method will return the output
         * data generated by the filter chain. 
         *
         * @param reset
         *      If true, calls resetFilters() after returning the output data in
         *      order to clean up any memory being held by the filters. (This 
         *      happens automatically if you call run() again or when the object
         *      is destructed.)
         */
        osg::NodeList getOutput( bool reset =true );


        /**
         * Gets the first filter in the script's filter chain.
         */
        Filter* getFirstFilter();


        /**
         * Finds a filter by its name. 
         */
        Filter* getFilter( const std::string& name );

    public:

        virtual ~Script();

    private:
        std::string                 name;
        osg::ref_ptr<ScriptContext> context;
        osg::ref_ptr<Filter>        first_filter;
        osg::ref_ptr<NodeFilter>    output_filter;
    };

    typedef std::list<osg::ref_ptr<Script> > ScriptList;
}


#endif // _OSGGIS_SCRIPT_H_