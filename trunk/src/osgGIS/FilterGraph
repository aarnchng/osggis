/**
 * osgGIS - GIS Library for OpenSceneGraph
 * Copyright 2007 Glenn Waldron and Pelican Ventures, Inc.
 * http://osggis.org
 *
 * osgGIS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef _OSGGIS_FILTER_GRAPH_H_
#define _OSGGIS_FILTER_GRAPH_H_ 1

#include <osgGIS/Common>
#include <osgGIS/FeatureFilter>
#include <osgGIS/FeatureStore>
#include <osgGIS/NodeFilter>
#include <osgGIS/FilterEnv>
#include <list>

namespace osgGIS
{
    /**
     * Holds the results of a filter graph run.
     */
    class OSGGIS_EXPORT FilterGraphResult
    {
    public:
        static FilterGraphResult ok();
        static FilterGraphResult error();
        
        bool isOK() const;
        
    private:
        FilterGraphResult( bool ok );
        
        bool is_ok;
    };
    
    
    /**
     * A chain of data-processing filters.
     *
     * A FilterGraph is a sequence of discrete data-processing units called Filters.
     * The compiler will run a graph using a set of input features (typically
     * from a FeatureStore/Featurelayer) and a filter environment (FilterEnv)
     * that communicates the current spatial context. The compiler passes data
     * from filter to filter until it reaches the end of the chain. It then
     * invokes getOutput() and returns the resulting scene graph to the caller.
     *
     * Although some basic type validation occurs, the responsibility lies with
     * the caller to build a working graph that passes compatible data down the
     * chain.
     */
    class OSGGIS_EXPORT FilterGraph : public osg::Referenced
    {
    public:
        /**
         * Construct a new, empty graph.
         */
        FilterGraph();

        /**
         * Gets the name of this graph.
         */
        const std::string& getName() const;

        /**
         * Sets the name of this graph.
         */
        void setName( const std::string& name );

        /**
         * Appends a filter to the end of the graph's filter chain.
         *
         * @param filter
         *      Filter to attach to the end of the chain. The filter's input
         *      requirements much be commpatible with the preceding filter's
         *      output specification.
         *
         * @return
         *      True if the filter appended succesfully.
         */
        bool appendFilter( Filter* filter );
        
        /**
         * Runs the graph to generate a scene graph.
         *
         * Executes the graph by passing features to the first filter in the
         * chain. That filter will process the data, pass the results along to
         * the next filter, and so on until completion.
         *
         * @param cursor
         *      Source cursor for features to process
         * @param env
         *      Contextual compilation environment
         * @param output
         *      Output node list of compiled scene graph
         * @return
         *      True if the filter chain completed without error; false otherwise.
         */
        FilterGraphResult computeNodes( 
            FeatureCursor& cursor, 
            FilterEnv*     env,
            osg::NodeList& output );
        
        FilterGraphResult computeFeatureStore(
            FeatureCursor&     cursor, 
            FilterEnv*         env,
            const std::string& output_uri );

        /**
         * Finds a filter by its name. 
         */
        Filter* getFilter( const std::string& name );

        /**
         * Gets the collection of filters in the graph.
         */
        const FilterList& getFilters() const;

        /**
         * Gets the collection of filters in the graph.
         */
        FilterList& getFilters();

    public:

        virtual ~FilterGraph();

    private:
        std::string name;
        FilterList filters;
    };

    typedef std::list<osg::ref_ptr<FilterGraph> > FilterGraphList;
}


#endif // _OSGGIS_FILTER_GRAPH_H_