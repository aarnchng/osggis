/* -*-c++-*- */
/* osgGIS - GIS Library for OpenSceneGraph
 * Copyright 2007-2008 Glenn Waldron and Pelican Ventures, Inc.
 * http://osggis.org
 *
 * osgGIS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef _OSGGISPROJECTS_MAP_LAYER_COMPILER_
#define _OSGGISPROJECTS_MAP_LAYER_COMPILER_ 1

#include <osgGISProjects/Common>
#include <osgGISProjects/MapLayer>
#include <osgGISProjects/QuadKey>
#include <osgGIS/ResourcePackager>
#include <osgGIS/TaskManager>
#include <osgGIS/SmartReadCallback>
#include <osgGIS/FeatureLayerCompiler>
#include <osgDB/Archive>

using namespace osgGIS;

namespace osgGISProjects
{
    class OSGGISPROJECTS_EXPORT Profile : public osg::Referenced
    {
    public:
        Profile() { }
    };

    /**
     * Compiles scene graphs from MapLayer definitions.
     */
    class OSGGISPROJECTS_EXPORT MapLayerCompiler : public osg::Referenced
    {
    public:
        /**
         * Constructs a new map layer compiler.
         *
         * @param map_layer
         *      Layer that we are going to compile.
         *
         * @param session
         *      Session under which to compiler the map layer
         */
        MapLayerCompiler( MapLayer* map_layer, Session* session =NULL );

        /**
         * Gets the map layer that this compiler is meant to compile.
         *
         * @return Map layer.
         */
        MapLayer* getMapLayer() const;

        /**
         * Sets whether the map layer is to be compiled into paged geometry.
         *
         * @param paged
         *      True to compile into paged cells, false for non-paged cells.
         */
        void setPaged( bool paged );

        /**
         * Gets whether to build a paged dataset.
         *
         * @return True if the map cells will be paged; false if not
         */
        bool getPaged() const;

        /**
         * Sets the absolute URI or pathname of the compiler output. This value will be
         * used as a template for creating output names for paged data cells as well as
         * localized resource files (textures, external models).
         *
         * This value is required if either the Paged of the CopyResourcesToOutputLocation
         * property is set to true. 
         *
         * @param uri
         *      Absolute URI/pathname
         */
        void setAbsoluteOutputURI( const std::string& uri );

        /**
         * Assigns an optional resource packager to the compiler. The resource packager will
         * prepare referenced resources (like texture skins and external models) and copy them
         * to the output location.
         *
         * @param packager
         *      Packager to use with this compiler.
         */
        void setResourcePackager( ResourcePackager* packager );

        /**
         * Gets the packager that will deploy resources and nodes for this compiler.
         */
        ResourcePackager* getResourcePackager() const;
                
        /** 
         * Sets the reference terrain against which to compile.
         */
        void setTerrain(
            osg::Node*              terrain, 
            const SpatialReference* terrain_srs,
            const GeoExtent&        terrain_extent );
           
        /** 
         * Sets the reference terrain against which to compile.
         */ 
        void setTerrain(
            osg::Node*              terrain, 
            const SpatialReference* terrain_srs );
            
        /**
         * Gets the scene graph holding the reference terrain, if set.
         */
        osg::Node* getTerrainNode();
        
        /**
         * Gets the spatial reference system of the reference terrain, if set.
         */
        SpatialReference* getTerrainSRS() const;
        
        /**
         * Gets the geospatial extents of the reference terrain, if set.
         */
        const GeoExtent& getTerrainExtent() const;
            
        /**
         * Sets the archive to which the compiler should write files,
         * if applicable.
         */
        void setArchive( osgDB::Archive* archive, const std::string& filename );
        
        /**
         * Gets the archive to which the compiler should write files, if set.
         */
        osgDB::Archive* getArchive();
        const std::string& getArchiveFileName() const;
            
        /* Gets the session under which this compiler will operate. */
        Session* getSession();

    public:
        /**
         * Gets the node graph containing the structure for data cells.
         *
         * @return A node graph
         */
        osg::Node* getSceneGraph();

        /**
         * Compiles the entire cell graph.
         *
         * @param task_man
         *      Task manager to employ for parallel/distributed compilation
         *
         * @return
         *      True if the compilation succeeded, false if it failed.
         */
        virtual bool compile( TaskManager* task_man =NULL);
        
        virtual bool compileIndexOnly();

    public:

        virtual Profile* createProfile() =0;

    public:

        class CellCompiler : public FeatureLayerCompiler {
        public:
            CellCompiler(
                const std::string& abs_output_uri,
                FeatureLayer*      layer,
                FilterGraph*       graph,
                float              min_range,
                float              max_range,
                FilterEnv*         env,
                ResourcePackager*  packager,
                osgDB::Archive*    archive =NULL);

            virtual void run();
            virtual void runSynchronousPostProcess( MapLayerCompiler*, Report* report );

        private:
            std::string abs_output_uri;
            osg::ref_ptr<osgDB::Archive> archive;
            osg::ref_ptr<ResourcePackager> packager;
            bool need_to_compile;
            bool has_drawables;
            float min_range, max_range;
        };

        std::string createAbsPathFromTemplate( const std::string& core );
        std::string createRelPathFromTemplate( const std::string& core );

    protected:

        virtual unsigned int queueTasks( Profile*, TaskManager* ) =0;
        virtual void buildIndex( Profile* ) =0;
        virtual void processCompletedTask( CellCompiler* ) { }

    protected:
        osg::ref_ptr<MapLayer>          map_layer;

        bool                            paged;
        std::string                     output_uri;
        osg::ref_ptr<ResourcePackager>  resource_packager;

        osg::ref_ptr<osgDB::Archive>    archive;
        std::string                     archive_filename;

        osg::ref_ptr<osg::Node>         terrain_node;
        osg::ref_ptr<SpatialReference>  terrain_srs;
        GeoExtent                       terrain_extent;

        osg::ref_ptr<Session>           session;

        osg::ref_ptr<osg::Group>        scene_graph;

        void setCenterAndRadius( osg::Node* plod_or_proxy, const GeoExtent& cell_extent, SmartReadCallback* reader );
    };
}

#endif // _OSGGISPROJECTS_MAP_LAYER_COMPILER_